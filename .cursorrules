# Financial Health Analyzer - Cursor Rules

## Project Overview
This is a comprehensive Financial Health Analyzer application built with TypeScript, HTML, and CSS. The application is research-based, implementing the Financial Health Network 2024 standards and 8 key financial health indicators.

## ðŸ”’ Security-First Development

### Critical Security Rules
- **NEVER commit real API keys, secrets, or credentials to version control**
- **ALWAYS use placeholder values in example files (e.g., .env.example)**
- **NEVER start development servers in production mode - use `npm run build` for testing**
- **ALWAYS validate and sanitize user inputs, especially financial data**
- **NEVER log sensitive financial information or API keys**
- **ALWAYS use environment variables for configuration, never hardcode secrets**

### API Key Security Protocol
1. **Real API keys ONLY in .env file (never committed)**
2. **Use .env.example for templates with placeholder values**
3. **Rotate API keys regularly in production**
4. **Monitor for accidental key exposure in logs or error messages**
5. **Use different keys for development and production environments**

### Development Server Security
- **PRIMARY RULE: Use `npm run build` for testing, NEVER start live servers unnecessarily**
- **Avoid server conflicts by building instead of running development servers**
- **If a server must be started, always stop it when done to prevent conflicts**
- **Use unique ports for any required development servers**
- **Never leave servers running unattended**

### Data Security for Financial Applications
- **Encrypt sensitive financial data at rest and in transit**
- **Implement proper input validation for all financial calculations**
- **Use secure random number generation for Monte Carlo simulations**
- **Sanitize all user inputs before processing**
- **Implement rate limiting for API calls**
- **Log security events but never log sensitive data**

## Architecture & Design Patterns

### Core Architecture
- **Modular Design**: Organized into `src/core/`, `src/components/`, `src/utils/`, `src/data/` directories
- **Object-Oriented Approach**: Use classes for main application logic and calculation engines
- **Type-First Development**: Comprehensive TypeScript interfaces defined in `src/types.ts`
- **Multi-Step Form Pattern**: Progressive data collection with validation at each step
- **Calculation Engine Pattern**: Centralized financial calculations in `FinancialCalculationEngine`

### File Organization Standards
```
src/
â”œâ”€â”€ core/                 # Core business logic and calculations
â”œâ”€â”€ components/           # Reusable UI components
â”‚   â”œâ”€â”€ forms/           # Form-related components
â”‚   â”œâ”€â”€ charts/          # Data visualization components
â”‚   â””â”€â”€ reports/         # Report generation components
â”œâ”€â”€ data/                # Static data and benchmarks
â”œâ”€â”€ utils/               # Utility functions
â”œâ”€â”€ styles/              # CSS modules and styling
â””â”€â”€ types.ts             # Comprehensive type definitions
```

## TypeScript Standards

### Type Definitions
- **Comprehensive Interfaces**: All data structures must be defined in `src/types.ts`
- **Financial Data Modeling**: Use the established interfaces (`UserFinancialData`, `HealthIndicator`, etc.)
- **Strict Typing**: Always prefer explicit types over `any`
- **Interface Naming**: Use descriptive names ending with `Data`, `Info`, `Result`, etc.
- **Security Types**: Define types for API responses and sensitive data structures

### Code Organization
- **Export Strategy**: Use named exports for classes and interfaces
- **Import Grouping**: Group imports by: Node modules, local modules, types
- **Class Structure**: Constructor â†’ Private methods â†’ Public methods â†’ Static methods
- **Security Methods**: Always place security-related methods as private when possible

## Financial Calculation Standards

### 8 Core Health Indicators (Research-Based)
1. **Spending vs Income Analysis** - Cash flow and expense ratios
2. **Bill Payment Reliability** - Payment history and consistency
3. **Emergency Savings Adequacy** - 3-6 month expense coverage
4. **Debt Management Effectiveness** - Debt-to-income ratios
5. **Credit Score Health** - Credit utilization and optimization
6. **Insurance Coverage Confidence** - Adequate protection analysis
7. **Long-term Financial Goal Confidence** - Retirement planning
8. **Financial Planning Engagement** - Budgeting and planning activities

### Calculation Principles
- **Research-Based Scoring**: Use Financial Health Network 2024 benchmarks
- **Weighted Scoring System**: Each indicator has specific weight in overall score
- **Status Categories**: 'excellent' | 'good' | 'fair' | 'poor' | 'critical'
- **Currency Formatting**: Always use `Intl.NumberFormat` with USD formatting
- **Secure Calculations**: Validate all inputs before performing financial calculations

## UI/UX Patterns

### Form Design
- **Progressive Disclosure**: Multi-step form with 6 clear steps
- **Real-time Validation**: Validate fields on change events with security checks
- **Accessibility**: Use proper labels, ARIA attributes, and semantic HTML
- **Responsive Design**: Mobile-first approach with CSS Grid/Flexbox
- **Input Sanitization**: Always sanitize form inputs before processing

### Visual Design System
```css
:root {
    --primary-color: #3b82f6;
    --secondary-color: #10b981;
    --accent-color: #f59e0b;
    --danger-color: #ef4444;
    /* Use established CSS custom properties */
}
```

### Component Patterns
- **Health Score Visualization**: Circular progress indicators with color coding
- **Indicator Cards**: Consistent card layout for health indicators
- **Status Colors**: Consistent color scheme across all status indicators
- **Loading States**: Always provide loading feedback for async operations
- **Error Boundaries**: Implement error boundaries to handle unexpected failures securely

## Development Standards

### Code Quality & Security
- **Error Handling**: Always wrap async operations in try-catch blocks
- **User Feedback**: Provide clear error messages without exposing sensitive information
- **Data Validation**: Validate all user inputs before processing with security checks
- **Performance**: Use efficient DOM manipulation and avoid unnecessary re-renders
- **Security Audits**: Regular code reviews focusing on security vulnerabilities

### Naming Conventions
- **Variables**: camelCase for variables and functions
- **Classes**: PascalCase for classes and interfaces
- **Constants**: UPPER_SNAKE_CASE for constants
- **CSS Classes**: kebab-case with BEM methodology where appropriate
- **Security Variables**: Prefix sensitive variables with `secure_` or `private_`

### Documentation
- **JSDoc Comments**: Use for all public methods and complex calculations
- **Inline Comments**: Explain complex financial calculations and business logic
- **Type Documentation**: Document interface properties with meaningful descriptions
- **Security Notes**: Document security considerations for sensitive functions

## Financial Domain Knowledge

### Key Metrics
- **Emergency Fund**: Target 3-6 months of expenses
- **Debt-to-Income**: Target < 36% total, < 28% housing
- **Savings Rate**: Target 10-20% of income
- **Credit Utilization**: Target < 30% of available credit
- **Asset Allocation**: Age-appropriate investment allocation

### Calculation Accuracy
- **Rounding**: Use appropriate rounding for financial calculations
- **Edge Cases**: Handle zero income, negative cash flow, missing data
- **Data Integrity**: Validate financial data relationships (assets vs liabilities)
- **Security Validation**: Ensure calculations cannot be manipulated through input tampering

## Implementation Guidelines

### When Adding New Features
1. **Security Assessment**: Evaluate security implications first
2. **Update Types First**: Add interfaces to `types.ts`
3. **Create Calculation Logic**: Add to `FinancialCalculationEngine` with validation
4. **Build UI Components**: Follow established component patterns with security
5. **Add Validation**: Implement proper form validation with security checks
6. **Update Documentation**: Keep comments and docs current
7. **Test Security**: Test for common vulnerabilities

### When Modifying Calculations
1. **Reference Research**: Base changes on financial industry standards
2. **Security Review**: Ensure changes don't introduce vulnerabilities
3. **Maintain Weights**: Keep health indicator weights balanced
4. **Test Edge Cases**: Verify calculations with various data scenarios
5. **Update Benchmarks**: Ensure peer comparison data is current
6. **Validate Inputs**: Re-check input validation after modifications

### Performance Considerations
- **Lazy Loading**: Load calculation results only when needed
- **Debounced Validation**: Avoid excessive validation calls
- **Efficient DOM Updates**: Minimize DOM manipulation
- **Memory Management**: Clean up event listeners and references
- **Secure Caching**: Use secure methods for caching sensitive data

## Testing Philosophy
- **Security Testing**: Test for XSS, injection attacks, and data leaks
- **User Input Validation**: Test all form validation scenarios
- **Calculation Accuracy**: Verify financial calculations with known values
- **UI Responsiveness**: Test across different screen sizes
- **Error Scenarios**: Test with invalid or missing data
- **API Security**: Test API interactions for security vulnerabilities

## ðŸš€ Development Speed Enhancements

### Quick Development Practices
- **Use npm run build for testing instead of starting servers**
- **Leverage existing TypeScript interfaces for rapid development**
- **Follow established component patterns for consistency**
- **Use code snippets for common financial calculation patterns**
- **Implement reusable security validation functions**

### AI Assistant Optimization
- **Provide clear context about financial domain requirements**
- **Reference existing code patterns and interfaces**
- **Use descriptive variable names for AI understanding**
- **Document complex financial formulas for AI context**

Remember: This application deals with sensitive financial data and provides analysis that users may base important decisions on. Always prioritize accuracy, security, and clear user communication. Security is not optional - it's fundamental to financial applications. 